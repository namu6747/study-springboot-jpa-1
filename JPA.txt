thymeleaf의 장단점
마크업을 깨지 않고 사용한다.
웹 브라우저에서 열린다.
스프링이랑 integration 됐음

요즘에는 서버사이드에서 렌더링하기보다는
리액트나 뷰.js같은 걸 많이 쓰기도 한다.

컨트롤러의 Model에 data를 실어서 뷰로 넘길 수 있다.
이때 return에는 화면 이름이 들어간다.

thymeleaf viewName 매핑
resoures:templates/ + {ViewName} + .html

서버 가동 중 파일 변경
implementation 'org.springframework.boot:spring-boot-devtools'
build -> recompile

application.properties vs application.yml
설정 파일이 많아지고 복잡해지면 yml이 낫다?

Repository의 EntityManager가 자동 주입 됨
starter-data-jpa가 해결해줌
yml에 다 등록해놨음

*command와 query를 분리해라
save의 return에 굳이 Id 정보를 반환 했는데 
Id 정도 있으면 써먹을 데가 있으니 해줌

엔티티매니저를 통한 모든 데이터 변경은 트랜잭션 안에서 이뤄져야함

# Entity 
"관리 되어야 하는 단위"   
현실 세계에서 다른 모든 것들과 구분되는 유형, 무형의 것   

*엔티티 선정시 유의사항*
-업무의 흐름(process)은 머리에서 지워라
-모호한 개념을 유의미하게 만들자
-예외 경우에 집착하지 말자

*애트리뷰트 선정시 유의사항*
-특정 attribute가 너무 많은 entity에 포함된다.
이때 해당 attribute가 entity가 될 가능성에 대해 고민
-필요한 attribute는 모두 고려하자
-시스템 관점의 attribute를 만들 때 고민하자

데이터베이스 팁
WHERE 사용시 컬럼값을 변경해서 비교하지말자
반드시 value를 수정하도록 하자

null이 허용되는 컬럼은 가능한 적게 디자인하자
null 허용 컬럼에 인덱스 걸지 마라

Getter는 모두 열되 Setter는 선택적으로 열자

같은 transaction 안에서(영속성 안에서)
영속성 context가 동일하다 ?
id 값이 같으면 같은 entity로 식별한다. == 연산자가 true다 ..

외부 라이브러리 사용할 때 성능 테스트 필수다.
병목 현상이 발생할 수 있음

공통 속성으로 id 값을 줬다. (PK, Generate)

many to many는 운영에서 쓰면 안된다.
가급적 양방향보단 단방향 연관 관계를 사용한다.

객체에서는 카테고리가 아이템을 리스트로 가져도 되고
아이템이 카테고리를 리스트로 가져도 된다.
RDBMS에서는 일반적인 설계론 그게 안된다.
중간에 매핑 테이블을 두고
1대다, 다대1 관계로 풀어내야 된다.

실제 코드에서는 DB에 소문자+ 언더스코어 스타일을 사용할 것임
테이블에서의 1대다 관계에서는 무조건 다에 외래키가 꽂힌다.
연관 관계의 주인은 외래키를 가진 테이블로 생각한다.

entity관련된 것을 domain package에 다 넣었음
@Column(name = "member_id") 이렇게 안하면 그냥 id로 column 명이 정해짐
Address는 JPA 내장 타입
내장타입을 쓸 때는 내장 클래스에 Embeddable을 작성하거나
필드에 선언하고 Embedded 둘 중 하나만 사용하면되나 보통 두 개를 같이 씀 
@JoinColumn(name = "member_id") FK를 member_id로 지정
@Enumerated(EnumType.STRING) Enum 필드 어노테이션
ORDINAL 사용하면 순서가 바뀌면 난리남

아키텍처에 너무 집착하면 실용성을 헤칠 수 있다.
controller에서 repository 직접 호출을 두려워하지 말자

?? JPA를 사용할 때 
스프링 @Transacional은 기본적으로 롤백 시키고
EntityManager도 주입한 뒤에 flush 메소드를 호출하면 commit 된다.


@RunWith(SpringRunner.class)
스프링이랑 같이 테스트하겠다.
@SpringBootTest
스프링부트를 띄운 상태로 테스트 하겠다.
없으면 Autowired 실패
스프링 컨테이너 안에서 테스트를 돌리겠다.
@Transactional
테스트가 끝나면 rollback을 하겠다(Test에서는)

데이터를 가지고 있는 데서 비즈니스 로직이 나가는 게
응집도가 있는 객체지향적 설계
: 주문 서비스의 주문과 주문 취소 메서드를 보면 
비즈니스 로직 대부분이 엔티티에 있다. 
서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다. 
이처럼 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 
적극 활용하는 것을 도메인 모델 패턴이라 한다. 
(http://martinfowler.com/eaaCatalog/domainModel.html)

일반적으로 sql 던지고 했을 땐 TSP를 썼다
반대로 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분
의 비즈니스 로직을 처리하는 것을 트랜잭션 스크립트 패턴이라 한다.
(http://martinfowler.com/eaaCatalog/transactionScript.html)

실제로 한 프로젝트에서 두 가지를 활용하기도 하므로
현상황에 맞는 대응책을 사용하면 된다.

@SpringBootTest처럼 컨테이너를 통으로 낀 테스트보단
순수 메소드 단위 테스트가 좋다.

JPA 동적 쿼리는 다 포기하고 Querydsl을 사용하든
Mybatis를 사용하자..








★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
GenerateValue와 sequence?





























